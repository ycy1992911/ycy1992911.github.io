<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Interface Oriented Programming · Mike Learns CS</title><meta name="description" content="Interface Oriented Programming - Mike Yan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.chongyangyan.me/atom.xml" title="Mike Learns CS"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ycy1992911" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Interface Oriented Programming</h1><div class="post-info">Apr 22, 2019</div><div class="post-content"><h1 id="The-Current-Design"><a href="#The-Current-Design" class="headerlink" title="The Current Design"></a>The Current Design</h1><p>Let’s take a look on the design below.</p>
<p><img src="/images/15590593372188.jpg" alt></p>
<p>In the diagram above, it is a standard object oriented design with a super-class of Duck, and other sub-classes to inherit from it. All the ducks can quack and swim, thus the jobs are handled to the super-class. Because each type of ducks(sub-classes) have different outlooks, so that the display() method in Duck is abstract.</p>
<h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><h1 id="A-New-Requirement-and-the-Code-Smell-of-Inheritance"><a href="#A-New-Requirement-and-the-Code-Smell-of-Inheritance" class="headerlink" title="A New Requirement and the Code Smell of Inheritance"></a>A New Requirement and the Code Smell of Inheritance</h1><p>A new requirement has been submitted to team. Our client wants to make sure that the duck can fly.<br>The normal way to do would be adding a method in the Duck class, and implement it in the sub-classes. It would be something like this:</p>
<p><img src="/images/15590593742234.jpg" alt></p>
<p>Now something horrible just happens, the RubberDuck can fly! The first idea comes to the team’s mind is inheritance. They are thinking about overriding the fly() method and make it empty inside. But a new problem is just around corn, what should they do if a DecoyDuck is added into the ducks family? It can neither fly or quack.<br>A bad smell of code will be spreading around like this:</p>
<p><img src="/images/15590598979896.jpg" alt></p>
<p>In this case, using inheritance to provide the Duck class’s behaviour is going to create some duplicates in the sub-classes and bringing in new behaviours that some sub-classes totally don’t want.</p>
<h1 id="Extracting-Behaviours-into-Interface-and-Duplicates-of-Code"><a href="#Extracting-Behaviours-into-Interface-and-Duplicates-of-Code" class="headerlink" title="Extracting Behaviours into Interface and Duplicates of Code"></a>Extracting Behaviours into Interface and Duplicates of Code</h1><p>The team clearly realised that inheritance may not be the best solution, they started thinking about extracting all the behaviour into interfaces. Something like this comes up on their mind:</p>
<p><img src="/images/15590608344112.jpg" alt></p>
<p>Apparently, the code here cannot be reused and more and more duplicated codes are added into the design. If there were other 200 sub-classes of the Duck and had implemented one of the interfaces, it will be a nightmare to make a slight change to any of the methods.</p>
<h1 id="Isolating-the-Change"><a href="#Isolating-the-Change" class="headerlink" title="Isolating the Change"></a>Isolating the Change</h1><p>What doesn’t change is that everything changes. The team now knows that inheritance cannot save their day because the duck’s behaviour constantly changes in the sub-classes, and it is inappropriate to allow all the sub-classes to inherit the same behaviour.</p>
<p>The idea of using Flyable and Quackable interfaces looks good at the beginning and solve the problem, but the interface in Java does not implement its methods, which means they are not reusable code. Whenever you want to change a behaviour, you have to track down the implementations and modify them, it can bring in new bugs. Luckily, there is a design principle that can be perfectly applied to this situation.</p>
<blockquote>
<p><strong><em>Design Principle</em></strong><br>Find the part might need to change in your application, extract it as an independent part, and separate it from the code that doesn’t need to change.</p>
</blockquote>
<p>In other word, whenever a new requirement comes to you, and will always require a change to be made to the same part of your code, that’s a signal to refactor and extract that part of the code.</p>
<p>#</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/04/23/What is ARTS/" class="prev">PREV</a><a href="/2018/02/26/符号表/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 - 2019 <a href="http://www.chongyangyan.me">Mike Yan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>